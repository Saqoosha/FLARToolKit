/** * MotionManContainer.as * This code based on  * https://github.com/abiyasa/perfume-stage3d/blob/master/simple-example/src/MotionMan3D.as */package{	import away3d.containers.ObjectContainer3D;	import away3d.containers.Scene3D;	import away3d.entities.Mesh;	import away3d.materials.ColorMaterial;	import away3d.materials.lightpickers.StaticLightPicker;	import away3d.primitives.CubeGeometry;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Point;	import flash.geom.Vector3D;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.*;		import com.perfume.utils.bvh.*;	public class MotionManContainer extends ObjectContainer3D	{				/** The bvh motion data */		private var _bvh:Bvh;				/** List of bone points */		private var _bonePoints:Array;				/** Rendering target */		private var _target:Scene3D;				private var _container:ObjectContainer3D;				private var _lightPicker:StaticLightPicker;		public function getBvh():Bvh		{			return this._bvh;		}				/**		 * Constructor with loading the BVH		 * @param	target		 * @param	path		 */		public function MotionManContainer(_stream:String, lightPicker:StaticLightPicker)		{			_lightPicker = lightPicker;			_bvh = new Bvh(_stream);			_bvh.isLoop = true;			this.createBonePoints(_bvh.bones);		}				public function destroy():void		{			if (_bvh)			{				_bvh.destroy();			}			_bvh = null;		}				/** Creates bone points based on list of bones */		private function createBonePoints(listOfBones:Vector.<BvhBone>):void		{			// TODO 5 is the number of bone ends. Should generate number dynamically			var num:int = _bvh.bones.length + 5;			_bonePoints = [];			var cube:Mesh;			var colorMaterial:ColorMaterial = new ColorMaterial(Math.random() * 0xFFFFFF);			colorMaterial.ambientColor = 0xFFFFFF;			colorMaterial.ambient = 0.5;			colorMaterial.specular = 0.1;			colorMaterial.specularLightSources = 4;			colorMaterial.lightPicker = _lightPicker;			for (var i:int = 0; i < num; i++ )			{				cube = new Mesh(new CubeGeometry(20, 20, 20), colorMaterial);				this.addChild(cube);				_bonePoints.push(cube);			}		}				/**		 * Calculate bone position matrix		 *		 * @param	bone The bone input		 * @param	matrix The matrix which will store the result		 */		private function calcBonePosition(bone:BvhBone, matrix:Matrix3D):void		{			// coordinate system in BVH is right-handed.			while (bone)			{				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendTranslation(bone.offsetX + bone.Xposition, bone.offsetY + bone.Yposition, bone.offsetZ + bone.Zposition);								bone = bone.parent;			}			// if BVH's coordinate system is left-handed then use below.			/*			while ( bone ) {				matrix.appendRotation(bone.Yrotation, Vector3D.Y_AXIS);				matrix.appendRotation(bone.Xrotation, Vector3D.X_AXIS);				matrix.appendRotation(bone.Zrotation, Vector3D.Z_AXIS);				matrix.appendTranslation(bone.Xposition+bone.offsetX, bone.Yposition+bone.offsetY, bone.Zposition+bone.offsetZ);				bone = bone.parent;			}			*/		}		/**		 * Update the motion/animation		 * @param	time		 */		public function update(time:Number):void		{						//frame of BVH			_bvh.gotoFrame(time / (_bvh.frameTime * 1000));						//calculate joint's position			// TODO optimize this, create positions array after parsing			var positions:Array = [];			for each (var bone:BvhBone in _bvh.bones)			{				var matrix:Matrix3D = new Matrix3D();				calcBonePosition(bone, matrix);				positions.push({ 'bone': bone, 'matrix': matrix });								// endSite				if (bone.isEnd)				{					matrix = new Matrix3D();					matrix.appendTranslation(bone.endOffsetX, bone.endOffsetY, bone.endOffsetZ);					calcBonePosition(bone, matrix);					positions.push({ 'bone': bone, 'matrix': matrix });				}			}						// re-adjust the position			var i:int = 0;			var len:int = positions.length;			var mesh:Mesh;			var matPos:Matrix3D;			var tempObj:Object;			const scale:Number = 3;			for ( i = 0; i < len; i++ )			{				mesh = _bonePoints[i];				tempObj = positions[i];				matPos = tempObj.matrix;				matPos.appendScale(scale, scale, scale);				mesh.transform = matPos;			}		}				/**		 * Search a specified bone from the given list		 *		 * @param	bone The specificed bone we want to search		 * @param	list List of objects containing bone and its matrix		 * @return the index of bone on the list. -1 if no bone found		 */		private function searchBoneFromBonePositionList(bone:BvhBone, list:Array):int		{			// find the index on positions			var found:Boolean = false;			var i:int = 0;			var len:int = list.length;			var tempObject:Object;			while ((i < len) && (!found))			{				tempObject = list[i];				if ((tempObject.bone as BvhBone) == bone)				{					found = true;				}				else				{					i++;				}			}						if (!found)			{				i = -1;			}						return i;		}	}}